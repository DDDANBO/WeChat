/*空间复杂度S(n) ―― 根据算法写成的程序在执行时
占用存储单元的长度。这个长度往往与输入数据的
规模有关。空间复杂度过高的算法可能导致使用的
内存超限，造成程序非正常中断。
时间复杂度T(n) ―― 根据算法写成的程序在执行时
耗费时间的长度。这个长度往往也与输入数据的规
模有关。时间复杂度过高的低效算法可能导致我们
在有生之年都等不到运行结果。
*/

double f( int n, double a[], double x ) {
	int i;
	double p = a[0];
	for ( i=1; i<=n; i++ )
		p += (a[i] * pow(x, i));
	return p;
}
(1+2+……+n)
    =(n2+n)/2次乘法
     T(n) = C1n^2+C2n

double f( int n, double a[], double x ) {
	int i;
	double p = a[n];
	for ( i=n; i>0; i-- )
		p = a[i-1] + x*p;
	return p;
}
n次乘法！
T(n) = C * n

复杂度的渐进表示法
. T(n) = O(f(n)) 表示存在常数C >0, n0>0 使得当
n>=n0 时有T(n) <= C*f(n)
. T(n) = Ω(g(n)) 表示存在常数C >0, n0>0 使得当
n>=n0 时有T(n) >= C*g(n)
. T(n) = Θ(h(n)) 表示同时有T(n) = O(h(n)) 和
T(n) = Ω(h(n))

复杂度分析小窍门
. 若两段算法分别有复杂度T1(n) = O(f1(n)) 和T2(n) =
O(f2(n))，则
. T1(n) + T2(n) = max( O(f1(n)), O(f2(n)) )
. T1(n) * T2(n) = O( f1(n) * f2(n) )
. 若T(n)是关于n的k阶多项式，那么T(n)=Θ(n^k)
. 一个for循环的时间复杂度等于循环次数乘以循环体
代码的复杂度
. if-else 结构的复杂度取决于if的条件判断复杂度
和两个分枝部分的复杂度，总体复杂度取三者中最大





